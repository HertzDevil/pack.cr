crystal_doc_search_index_callback({"repository_name":"pack.cr","body":"# pack.cr\n\n![Linux status](https://img.shields.io/github/workflow/status/HertzDevil/pack.cr/Linux%20CI?label=Linux)\n![macOS status](https://img.shields.io/github/workflow/status/HertzDevil/pack.cr/macOS%20CI?label=macOS)\n![Windows status](https://img.shields.io/github/workflow/status/HertzDevil/pack.cr/Windows%20CI?label=Windows)\n![Docs status](https://img.shields.io/github/deployments/HertzDevil/pack.cr/github-pages?label=docs)\n![License](https://img.shields.io/github/license/HertzDevil/pack.cr)\n\nThis Crystal library provides macros that transform simple values to and from\nbyte sequences according to compile-time format strings, based on Perl and\nRuby's `pack` and `unpack` functions. Packing enforces full type safety and\nunpacking directly returns extracted values in their specified types.\n\nThe library is still under early development.\n\n## Usage\n\n### `Pack.pack`\n\n```crystal\nrequire \"pack\"\n\n# `Pack.pack` returns a new writable `Bytes`\nPack.pack \"csl>\", 42_i8, -1000_i16, 1 << 31 # => Bytes[42, 24, 252, 128, 0, 0, 0]\n\n# `Pack.pack_to` writes to an `IO` instance\nFile.open(\"my.bin\", \"rb\") do |f|\n  version = 1_u8\n  total_songs = 5_u8\n  first_song = 1_u8\n  Pack.pack_to f, \"U4CCCCS*\",\n    {'N', 'E', 'S', 'M'}, 0x1A, version, # 0x1A allowed due to auto-casting\n    total_songs, first_song, [0x8000, 0xE000, 0xE003] of UInt16\nend\n```\n\n### `Pack.unpack`\n\n```crystal\nrequire \"pack\"\n\n# The following:\nPack.unpack buf, \"c2S!>a*\"\n\n# roughly expands to:\ndef unpack(buf : Bytes)\n  byte_offset = 0\n\n  sz = sizeof(Int8)\n  value1 = StaticArray(Int8, 2).new do |i|\n    IO::ByteFormat::SystemEndian.decode(Int8, buf[byte_offset + sz * i, sz])\n  end\n  byte_offset += sz * 2\n\n  sz = sizeof(UInt16)\n  value2 = IO::ByteFormat::BigEndian.decode(UInt16, buf[byte_offset, sz])\n  byte_offset += sz\n\n  elem_count = buf.size - byte_offset\n  value3 = buf[byte_offset, elem_count]\n  byte_offset += elem_count\n\n  Tuple.new(value1, value2, value3)\nend\n\n# `Pack.unpack` returns a tuple of extracted values\nx1, x2, x3 = Pack.unpack Bytes[0x01, 0xC8, 0x03, 0x04], \"cCs\"\nx1 # => 1_i8\nx2 # => 200_u8\nx3 # => 1027_i16\n\n# No need for further casts\ntypeof(x1) # => Int8\ntypeof(x2) # => UInt8\ntypeof(x3) # => Int16\n\n# Repeat counts and globs become `StaticArray`s and `Array`s\nx1, x2 = Pack.unpack Bytes[1, 0, 2, 0, 3, 0], \"c2s>*\"\nx1 # => StaticArray[1_i8, 0_i8]\nx2 # => [512_i16, 768_i16]\n\n# Binaries become `Bytes`, UTF-8 values become `Char`s and `String`s\nx1, x2, x3 = Pack.unpack Bytes[0x41, 0x42, 0x43, 0x31, 0x32, 0x33, 0x34], \"a2U2U*\"\nx1 # => Bytes[65, 66]\nx2 # => \"C1\"\nx3 # => \"234\"\n```\n\n### Current features\n\n* [ ] Packing\n  * [x] Fixed-size integral types (`c` `C` `s` `S` `l` `L` `q` `Q` `n` `N` `v` `V`)\n  * [x] Native integral types (`i` `I` `l` `L` `j` `J`)\n  * [x] Native size modifiers (`_` `!`)\n  * [x] Endianness modifiers (`<` `>`)\n  * [x] Floating-point types (`d` `f` `F` `e` `E` `g` `G`)\n  * [x] BER-compressed integers (`w`)\n  * [ ] Binary strings (`a` `A` `Z`)\n  * [ ] UTF-8 characters / strings (`U` `U*`)\n  * [x] Bitstrings and hexstrings (`b` `B` `h` `H`)\n  * [ ] Raw pointers and slices (`p` `P`)\n  * [ ] UU-encoded strings (`u`)\n  * [ ] Base64-encoded strings (`m` `M`)\n  * [ ] String lengths (`/`)\n  * [ ] Offset directives (`@` `x` `X`)\n  * [ ] Aligned offsets (`x!` `X!`)\n  * [x] Repeat counts and globs (`*`)\n* [ ] Unpacking\n  * [x] Fixed-size integral types (`c` `C` `s` `S` `l` `L` `q` `Q` `n` `N` `v` `V`)\n  * [x] Native integral types (`i` `I` `l` `L` `j` `J`)\n  * [x] Native size modifiers (`_` `!`)\n  * [x] Endianness modifiers (`<` `>`)\n  * [x] Floating-point types (`d` `f` `F` `e` `E` `g` `G`)\n  * [x] BER-compressed integers (`w`)\n  * [x] Binary strings (`a` `A` `Z`)\n  * [x] UTF-8 characters / strings (`U` `U*`)\n  * [x] Bitstrings and hexstrings (`b` `B` `h` `H`)\n  * [x] Raw pointers and slices (`p` `P`)\n  * [ ] UU-encoded strings (`u`)\n  * [ ] Base64-encoded strings (`m` `M`)\n  * [ ] String lengths (`/`)\n  * [x] Offset directives (`@` `x` `X`)\n  * [ ] Aligned offsets (`x!` `X!`)\n  * [x] Repeat counts and globs (`*`)\n  * [ ] Unpacking directly from readable & rewindable `IO`?\n\n### Non-features (probably)\n\n* Runtime format strings\n* Long double (`D`)\n* Signed modifier (`!`) for `n` `N` `v` `V`\n* Endianness modifiers (`<` `>`) for `d` `f` `F`\n* Checksums (`%`)\n* Command groups (`(` `)` `.`)\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     pack.cr:\n       github: HertzDevil/pack.cr\n   ```\n\n2. Run `shards install`\n\n## See also\n\n* [crystal-lang/crystal#276](https://github.com/crystal-lang/crystal/issues/276)\n* [\"Crystal equivalent of Rubyâ€™s open(url).read[].unpack?\"](https://forum.crystal-lang.org/t/crystal-equivalent-of-rubys-open-url-read-unpack/2667)\n* [Prior attempt](https://github.com/Fusion/crystal-pack)\n* [perlpacktut](https://perldoc.perl.org/perlpacktut)\n* [Ruby's String#unpack](https://ruby-doc.org/core-3.0.0/String.html#method-i-unpack)\n* [Ruby's Array#pack](https://ruby-doc.org/core-3.0.0/Array.html#method-i-pack)\n\n## Contributing\n\n1. Fork it (<https://github.com/HertzDevil/pack.cr/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n* [Quinton Miller](https://github.com/HertzDevil) - creator and maintainer\n","program":{"html_id":"pack.cr/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"pack.cr","program":true,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"pack.cr/Pack","path":"Pack.html","kind":"module","full_name":"Pack","name":"Pack","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/pack.cr","line_number":5,"url":"https://github.com/HertzDevil/pack.cr/blob/899a0b1a20bc4525100e2c31fe20c7fd94768a88/src/pack.cr#L5"},{"filename":"src/pack/pack_impl.cr","line_number":2,"url":"https://github.com/HertzDevil/pack.cr/blob/899a0b1a20bc4525100e2c31fe20c7fd94768a88/src/pack/pack_impl.cr#L2"},{"filename":"src/pack/pack_impl.cr","line_number":351,"url":"https://github.com/HertzDevil/pack.cr/blob/899a0b1a20bc4525100e2c31fe20c7fd94768a88/src/pack/pack_impl.cr#L351"},{"filename":"src/pack/unpack_impl.cr","line_number":391,"url":"https://github.com/HertzDevil/pack.cr/blob/899a0b1a20bc4525100e2c31fe20c7fd94768a88/src/pack/unpack_impl.cr#L391"}],"repository_name":"pack.cr","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.1.0\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"Crystal port of Perl / Ruby's `pack` / `unpack` functions.","summary":"<p>Crystal port of Perl / Ruby's <code><a href=\"Pack.html#pack(fmt,*args)-macro\">pack</a></code> / <code><a href=\"Pack.html#unpack(bytes,fmt)-macro\">unpack</a></code> functions.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[{"id":"pack(fmt,*args)-macro","html_id":"pack(fmt,*args)-macro","name":"pack","doc":null,"summary":null,"abstract":false,"args":[{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(fmt, *args)","location":{"filename":"src/pack/pack_impl.cr","line_number":475,"url":"https://github.com/HertzDevil/pack.cr/blob/899a0b1a20bc4525100e2c31fe20c7fd94768a88/src/pack/pack_impl.cr#L475"},"def":{"name":"pack","args":[{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":1,"block_arg":null,"visibility":"Public","body":"    \n%io\n = ::Pack::PackImpl::BytesWriter.new\n    ::Pack.pack_to(\n%io\n, \n{{ fmt }}\n, \n{{ args.splat }}\n)\n    \n%io\n.to_slice\n  \n"}},{"id":"pack_to(io,fmt,*args)-macro","html_id":"pack_to(io,fmt,*args)-macro","name":"pack_to","doc":null,"summary":null,"abstract":false,"args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""},{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(io, fmt, *args)","location":{"filename":"src/pack/pack_impl.cr","line_number":352,"url":"https://github.com/HertzDevil/pack.cr/blob/899a0b1a20bc4525100e2c31fe20c7fd94768a88/src/pack/pack_impl.cr#L352"},"def":{"name":"pack_to","args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""},{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":2,"block_arg":null,"visibility":"Public","body":"    \n{% if fmt.is_a?(Path) %}\n      {% fmt = fmt.resolve %}\n    {% end %}\n\n    \n{% if fmt.is_a?(StringLiteral) %}{% else %}\n      {% fmt.raise(\"format must be a string literal or constant\") %}\n    {% end %}\n\n\n    \n{% commands = [] of ASTNode %}\n\n    \n{% current = {directive: nil} %}\n\n\n    \n{% chars = fmt.chars %}\n\n    \n{% chars << ' ' %}\n\n    \n{% accepts_modifiers = false %}\n\n\n    \n{% for ch, index in chars %}\n      {% if \"cCsSlLqQiIjJnNvVdfFeEgGUwaAZbBhHumMpP@xX \\n\\t\\f\\v\\r\".includes?(ch) %}\n        {% if current[:directive] %}\n          {% current[:name] = chars[current[:index]...index].join(\"\") %}\n          {% commands << current %}\n        {% end %}\n\n        {% current = {directive: nil, index: index} %}\n        {% accepts_modifiers = false %}\n\n        {% if \" \\n\\t\\f\\v\\r\".includes?(ch) %}{% else %}\n          {% current[:directive] = ch %}\n          {% accepts_modifiers = \"sSlLqQjJiI\".includes?(ch) %}\n        {% end %}\n\n      {% else %}{% if (ch == '_') || (ch == '!') %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% current[:bang] = true %}\n\n      {% else %}{% if ch == '<' %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% if current[:endianness] == (:BigEndian)\n  fmt.raise(\"can't use both '<' and '>'\")\nend %}\n        {% current[:endianness] = :LittleEndian %}\n      {% else %}{% if ch == '>' %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% if current[:endianness] == (:LittleEndian)\n  fmt.raise(\"can't use both '<' and '>'\")\nend %}\n        {% current[:endianness] = :BigEndian %}\n\n      {% else %}{% if ch == '*' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:directive] == '@'\n  fmt.raise(\"#{ch} not allowed for '@'\")\nend %}\n        {% if current[:directive] == 'P'\n  fmt.raise(\"#{ch} not allowed for 'P'\")\nend %}\n        {% if current[:count]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:glob] = true %}\n\n      {% else %}{% if ch == '0' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 0 %}\n      {% else %}{% if ch == '1' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 1 %}\n      {% else %}{% if ch == '2' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 2 %}\n      {% else %}{% if ch == '3' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 3 %}\n      {% else %}{% if ch == '4' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 4 %}\n      {% else %}{% if ch == '5' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 5 %}\n      {% else %}{% if ch == '6' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 6 %}\n      {% else %}{% if ch == '7' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 7 %}\n      {% else %}{% if ch == '8' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 8 %}\n      {% else %}{% if ch == '9' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 9 %}\n\n      {% else %}{% if ch == 'D' %}\n        {% fmt.raise(\"long double is not supported, use 'd' instead\") %}\n\n      {% else %}\n        {% fmt.raise(\"unexpected directive: #{ch}\") %}\n      {% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}\n    {% end %}\n\n\n    io = (\n{{ io }}\n).as(::IO)\n    byte_offset = 0\n\n    \n{% arg_pos = 0 %}\n\n    \n{% for command in commands %}\n      {% if (command[:directive] == 'P') && command[:count] %}\n        {% fmt.raise(\"count not allowed for 'P'\") %}\n      {% end %}\n      {% if arg_pos >= args.size %}\n        {% args.raise(\"missing argument for directive #{name}\") %}\n      {% end %}\n      {% arg = args[arg_pos] %}\n      {% arg_pos += 1 %}\n      Pack::PackImpl.do_pack1({{ arg }}, {{ command }})\n    {% end %}\n\n\n    \n{% if arg_pos < args.size %}\n      {% args.raise(\"wrong number of values for Pack.pack (expected #{arg_pos}, got #{args.size})\") %}\n    {% end %}\n\n  \n"}},{"id":"unpack(bytes,fmt)-macro","html_id":"unpack(bytes,fmt)-macro","name":"unpack","doc":"Unpacks a buffer of *bytes* according to the given format string *fmt*.\nReturns a `Tuple` of unpacked values, without flattening directives that\ncontain repeat counts.\n\n*bytes* must be a `Slice(UInt8)`. *fmt* must be a string literal or constant\nrepresenting a valid sequence of unpacking directives.\n\n```\nPack.unpack(Bytes[0x01, 0xE8, 0x03, 0x05, 0xF5, 0xE1, 0x00], \"csl>\") # => {1_i8, 1000_i16, 100000000}\nPack.unpack(\"abcd\\x00ef\\x00\".to_slice, \"CCZ*a*\")                     # => {StaticArray[97_u8, 98_u8], Bytes[99, 100], Bytes[101, 102, 0]}\n```","summary":"<p>Unpacks a buffer of <em>bytes</em> according to the given format string <em>fmt</em>.</p>","abstract":false,"args":[{"name":"bytes","doc":null,"default_value":"","external_name":"bytes","restriction":""},{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""}],"args_string":"(bytes, fmt)","location":{"filename":"src/pack/unpack_impl.cr","line_number":403,"url":"https://github.com/HertzDevil/pack.cr/blob/899a0b1a20bc4525100e2c31fe20c7fd94768a88/src/pack/unpack_impl.cr#L403"},"def":{"name":"unpack","args":[{"name":"bytes","doc":null,"default_value":"","external_name":"bytes","restriction":""},{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"    \n{% if fmt.is_a?(Path) %}\n      {% fmt = fmt.resolve %}\n    {% end %}\n\n    \n{% if fmt.is_a?(StringLiteral) %}{% else %}\n      {% fmt.raise(\"format must be a string literal or constant\") %}\n    {% end %}\n\n\n    \n{% commands = [] of ASTNode %}\n\n    \n{% current = {directive: nil} %}\n\n\n    \n{% chars = fmt.chars %}\n\n    \n{% chars << ' ' %}\n\n    \n{% accepts_modifiers = false %}\n\n\n    \n{% for ch, index in chars %}\n      {% if \"cCsSlLqQiIjJnNvVdfFeEgGUwaAZbBhHumMpP@xX \\n\\t\\f\\v\\r\".includes?(ch) %}\n        {% if current[:directive] %}\n          {% current[:name] = chars[current[:index]...index].join(\"\") %}\n          {% commands << current %}\n        {% end %}\n\n        {% current = {directive: nil, index: index} %}\n        {% accepts_modifiers = false %}\n\n        {% if \" \\n\\t\\f\\v\\r\".includes?(ch) %}{% else %}\n          {% current[:directive] = ch %}\n          {% accepts_modifiers = \"sSlLqQjJiI\".includes?(ch) %}\n        {% end %}\n\n      {% else %}{% if (ch == '_') || (ch == '!') %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% current[:bang] = true %}\n\n      {% else %}{% if ch == '<' %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% if current[:endianness] == (:BigEndian)\n  fmt.raise(\"can't use both '<' and '>'\")\nend %}\n        {% current[:endianness] = :LittleEndian %}\n      {% else %}{% if ch == '>' %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% if current[:endianness] == (:LittleEndian)\n  fmt.raise(\"can't use both '<' and '>'\")\nend %}\n        {% current[:endianness] = :BigEndian %}\n\n      {% else %}{% if ch == '*' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:directive] == '@'\n  fmt.raise(\"#{ch} not allowed for '@'\")\nend %}\n        {% if current[:directive] == 'P'\n  fmt.raise(\"#{ch} not allowed for 'P'\")\nend %}\n        {% if current[:count]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:glob] = true %}\n\n      {% else %}{% if ch == '0' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 0 %}\n      {% else %}{% if ch == '1' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 1 %}\n      {% else %}{% if ch == '2' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 2 %}\n      {% else %}{% if ch == '3' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 3 %}\n      {% else %}{% if ch == '4' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 4 %}\n      {% else %}{% if ch == '5' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 5 %}\n      {% else %}{% if ch == '6' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 6 %}\n      {% else %}{% if ch == '7' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 7 %}\n      {% else %}{% if ch == '8' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 8 %}\n      {% else %}{% if ch == '9' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 9 %}\n\n      {% else %}{% if ch == 'D' %}\n        {% fmt.raise(\"long double is not supported, use 'd' instead\") %}\n\n      {% else %}\n        {% fmt.raise(\"unexpected directive: #{ch}\") %}\n      {% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}\n    {% end %}\n\n\n    obj = Pack::UnpackImpl.to_slice(\n{{ bytes }}\n)\n    byte_offset = 0\n\n    \n{% used_indices = [] of ASTNode %}\n\n    \n{% for command in commands %}\n      {% if \"@xX\".includes?(command[:directive]) %}\n        Pack::UnpackImpl.do_unpack1({{ command }})\n      {% else %}\n        %values{command[:index]} = Pack::UnpackImpl.do_unpack1({{ command }})\n        {% used_indices << command[:index] %}\n      {% end %}\n    {% end %}\n\n\n    Tuple.new(\n      \n{% for index in used_indices %}\n        %values{index},\n      {% end %}\n\n    )\n  \n"}}],"types":[]}]}})