{"repository_name":"pack.cr","body":"# pack.cr\n\n![Linux status](https://img.shields.io/github/workflow/status/HertzDevil/pack.cr/Linux%20CI?label=Linux)\n![macOS status](https://img.shields.io/github/workflow/status/HertzDevil/pack.cr/macOS%20CI?label=macOS)\n![Windows status](https://img.shields.io/github/workflow/status/HertzDevil/pack.cr/Windows%20CI?label=Windows)\n![Docs status](https://img.shields.io/github/deployments/HertzDevil/pack.cr/github-pages?label=docs)\n![License](https://img.shields.io/github/license/HertzDevil/pack.cr)\n\nThis Crystal library provides macros that transform simple values to and from\nbyte sequences according to compile-time format strings, based on Perl and\nRuby's `pack` and `unpack` functions. Packing enforces full type safety and\nunpacking directly returns extracted values in their specified types.\n\nThe library is still under early development.\n\n## Usage\n\n### `Pack.pack`\n\n```crystal\nrequire \"pack\"\n\n# `Pack.pack` returns a new writable `Bytes`\nPack.pack \"csl>\", 42_i8, -1000_i16, 1 << 31 # => Bytes[42, 24, 252, 128, 0, 0, 0]\n\n# `Pack.pack_to` writes to an `IO` instance\nFile.open(\"my.bin\", \"rb\") do |f|\n  version = 1_u8\n  total_songs = 5_u8\n  first_song = 1_u8\n  Pack.pack_to f, \"U4CCCCS*\",\n    {'N', 'E', 'S', 'M'}, 0x1A, version, # 0x1A allowed due to auto-casting\n    total_songs, first_song, [0x8000, 0xE000, 0xE003] of UInt16\nend\n```\n\n### `Pack.unpack`\n\n```crystal\nrequire \"pack\"\n\n# The following:\nPack.unpack buf, \"c2S!>a*\"\n\n# roughly expands to:\ndef unpack(buf : Bytes)\n  byte_offset = 0\n\n  sz = sizeof(Int8)\n  value1 = StaticArray(Int8, 2).new do |i|\n    IO::ByteFormat::SystemEndian.decode(Int8, buf[byte_offset + sz * i, sz])\n  end\n  byte_offset += sz * 2\n\n  sz = sizeof(UInt16)\n  value2 = IO::ByteFormat::BigEndian.decode(UInt16, buf[byte_offset, sz])\n  byte_offset += sz\n\n  elem_count = buf.size - byte_offset\n  value3 = buf[byte_offset, elem_count]\n  byte_offset += elem_count\n\n  Tuple.new(value1, value2, value3)\nend\n\n# `Pack.unpack` returns a tuple of extracted values\nx1, x2, x3 = Pack.unpack Bytes[0x01, 0xC8, 0x03, 0x04], \"cCs\"\nx1 # => 1_i8\nx2 # => 200_u8\nx3 # => 1027_i16\n\n# No need for further casts\ntypeof(x1) # => Int8\ntypeof(x2) # => UInt8\ntypeof(x3) # => Int16\n\n# Repeat counts and globs become `StaticArray`s and `Array`s\nx1, x2 = Pack.unpack Bytes[1, 0, 2, 0, 3, 0], \"c2s>*\"\nx1 # => StaticArray[1_i8, 0_i8]\nx2 # => [512_i16, 768_i16]\n\n# Binaries become `Bytes`, UTF-8 values become `Char`s and `String`s\nx1, x2, x3 = Pack.unpack Bytes[0x41, 0x42, 0x43, 0x31, 0x32, 0x33, 0x34], \"a2U2U*\"\nx1 # => Bytes[65, 66]\nx2 # => \"C1\"\nx3 # => \"234\"\n```\n\n### Current features\n\n* [ ] Packing\n  * [x] Fixed-size integers (`c` `C` `s` `S` `l` `L` `q` `Q` `n` `N` `v` `V`)\n  * [x] Native integers (`i` `I` `j` `J`)\n  * [x] Native size modifiers (`_` `!`)\n  * [x] Endianness modifiers (`<` `>`)\n  * [x] Floating-point values (`d` `f` `F` `e` `E` `g` `G`)\n  * [x] BER-compressed integers (`w`)\n  * [ ] Binary strings (`a` `A` `Z`)\n  * [ ] UTF-8 characters / strings (`U` `U*`)\n  * [x] Bitstrings and hexstrings (`b` `B` `h` `H`)\n  * [ ] Raw pointers and slices (`p` `P`)\n  * [ ] UU-encoded strings (`u`)\n  * [ ] Base64-encoded strings (`m` `M`)\n  * [ ] String lengths (`/`)\n  * [ ] Offset directives (`@` `x` `X`)\n  * [ ] Aligned offsets (`x!` `X!`)\n  * [x] Repeat counts and globs (`*`)\n* [ ] Unpacking\n  * [x] Fixed-size integers (`c` `C` `s` `S` `l` `L` `q` `Q` `n` `N` `v` `V`)\n  * [x] Native integers (`i` `I` `j` `J`)\n  * [x] Native size modifiers (`_` `!`)\n  * [x] Endianness modifiers (`<` `>`)\n  * [x] Floating-point values (`d` `f` `F` `e` `E` `g` `G`)\n  * [x] BER-compressed integers (`w`)\n  * [x] Binary strings (`a` `A` `Z`)\n  * [x] UTF-8 characters / strings (`U` `U*`)\n  * [x] Bitstrings and hexstrings (`b` `B` `h` `H`)\n  * [x] Raw pointers and slices (`p` `P`)\n  * [ ] UU-encoded strings (`u`)\n  * [ ] Base64-encoded strings (`m` `M`)\n  * [ ] String lengths (`/`)\n  * [x] Offset directives (`@` `x` `X`)\n  * [ ] Aligned offsets (`x!` `X!`)\n  * [x] Repeat counts and globs (`*`)\n  * [ ] Unpacking directly from readable & rewindable `IO`?\n\n### Non-features (probably)\n\n* Runtime format strings\n* Long double (`D`)\n* Signed modifier (`!`) for `n` `N` `v` `V`\n* Endianness modifiers (`<` `>`) for `d` `f` `F`\n* Checksums (`%`)\n* Command groups (`(` `)` `.`)\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     pack.cr:\n       github: HertzDevil/pack.cr\n   ```\n\n2. Run `shards install`\n\n## See also\n\n* [crystal-lang/crystal#276](https://github.com/crystal-lang/crystal/issues/276)\n* [\"Crystal equivalent of Rubyâ€™s open(url).read[].unpack?\"](https://forum.crystal-lang.org/t/crystal-equivalent-of-rubys-open-url-read-unpack/2667)\n* [Prior attempt](https://github.com/Fusion/crystal-pack)\n* [perlpacktut](https://perldoc.perl.org/perlpacktut)\n* [Ruby's String#unpack](https://ruby-doc.org/core-3.0.0/String.html#method-i-unpack)\n* [Ruby's Array#pack](https://ruby-doc.org/core-3.0.0/Array.html#method-i-pack)\n\n## Contributing\n\n1. Fork it (<https://github.com/HertzDevil/pack.cr/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n* [Quinton Miller](https://github.com/HertzDevil) - creator and maintainer\n","program":{"html_id":"pack.cr/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"pack.cr","program":true,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"pack.cr/Pack","path":"Pack.html","kind":"module","full_name":"Pack","name":"Pack","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/pack.cr","line_number":128,"url":"https://github.com/HertzDevil/pack.cr/blob/09a8370973e7a1b763a2b2485d0de2362e84ffc6/src/pack.cr#L128"},{"filename":"src/pack/pack_impl.cr","line_number":1,"url":"https://github.com/HertzDevil/pack.cr/blob/09a8370973e7a1b763a2b2485d0de2362e84ffc6/src/pack/pack_impl.cr#L1"},{"filename":"src/pack/unpack_impl.cr","line_number":1,"url":"https://github.com/HertzDevil/pack.cr/blob/09a8370973e7a1b763a2b2485d0de2362e84ffc6/src/pack/unpack_impl.cr#L1"}],"repository_name":"pack.cr","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.1.0\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"Crystal port of Perl / Ruby's `pack` / `unpack` functions.\n\nThe basic usage is `Pack.pack_to` for writing to an `IO`, and `Pack.unpack`\nfor reading from a `Bytes`. The function `Pack.pack` writes to a new `Bytes`\nand returns it.\n\n```\nrequire \"pack\"\n\nPack.unpack Bytes[0x01, 0xC8, 0x03, 0x04], \"cCs\" # => {1_i8, 200_u8, 1027_i16}\nPack.pack \"csl>\", 42_i8, -1000_i16, 1 << 31      # => Bytes[42, 24, 252, 128, 0, 0, 0]\n```\n\nThe format string consists of any number of commands, which consist of a\ndirective (usually indicating the type of value to be read or written),\noptionally followed by an integer count or a glob (`*`). Whitespaces between\ncommands are ignored, but must not appear in the middle of a command. The\ndirectives are classified as below:\n\n* [Fixed-size integers](#fixed-size-integers) (`c` `C` `s` `S` `l` `L` `q` `Q` `n` `N` `v` `V`)\n* [Native integers](#native-integers) (`i` `I` `j` `J`)\n* [Floating-point values](#floating-point-values) (`d` `f` `F` `e` `E` `g` `G`)\n* BER-compressed integers (`w`)\n* Binary strings (`a` `A` `Z`)\n* UTF-8 characters / strings (`U` `U*`)\n* Bitstrings and hexstrings (`b` `B` `h` `H`)\n* Raw pointers and slices (`p` `P`)\n* UU-encoded strings (`u`)\n* Base64-encoded strings (`m` `M`)\n\n### Fixed-size integers\n\nThese directives pack and unpack values of type `T`, where `T` <\n`Int::Primitive`. The type `T` depends on the directive being used:\n\n* `Int8`: `c`\n* `UInt8`: `C`\n* `Int16`: `s`\n* `UInt16`: `S`\n* `Int32`: `l`\n* `UInt32`: `L`\n* `Int64`: `q`\n* `UInt64`: `Q`\n\nDue to auto-casting, compatible integer literals are allowed during packing:\n\n```\nPack.pack(\"cs\", 1, 1) # => Bytes[1, 1, 0]\n```\n\nThese directives obey the system endianness, unless an endianness modifier is\nsupplied. `<` and `>` force the command to use little-endian and big-endian\nrespectively. The two modifiers cannot be specified in the same command.\n\nThe `_` or `!` modifier forces the command to use native-size integers\ninstead. See [Native integers](#native-integers) for the corresponding integer\ntypes used.\n\nThe following aliases are defined:\n\n* `n` is equivalent to `S>` (stands for network byte order)\n* `N` is equivalent to `L>`\n* `v` is equivalent to `S<` (stands for\n  [VAX](https://en.wikipedia.org/wiki/VAX) byte order)\n* `V` is equivalent to `L<`\n\nEndianness and native-size modifiers are not allowed after `c`, `C`, `n`, `N`,\n`v`, and `V`.\n\nRepeat counts are supported. Unpacking produces values of type\n`StaticArray(T, N)`, where `N` is the count specified in the command. Packing\naccepts any `Enumerable` that is a collection of the appropriate element type.\nIf the value does not contain as many elements as specified, `IndexError` is\nraised.\n\nGlobs are supported. Unpacking produces values of type `Array(T)`. Packing\naccepts any `Enumerable` that is a collection of the appropriate element type.\n\n### Native integers\n\nThese directives pack and unpack values of type `T`, where `T` <\n`Int::Primitive`. The type `T` depends on the directive being used:\n\n* `LibC::Short`: `s!`\n* `LibC::UShort`: `S!`\n* `LibC::Int`: `i` `i!`\n* `LibC::UInt`: `I` `I!`\n* `LibC::Long`: `l!`\n* `LibC::ULong`: `L!`\n* `LibC::LongLong`: `q!`\n* `LibC::ULongLong`: `Q!`\n* `LibC::Int64T`: `j` `j!` (stands for C's `intptr_t`)\n* `LibC::UInt64T`: `J` `J!` (stands for C's `uintptr_t`)\n\nEndianness modifiers are allowed on all of them, and have the same effect as\nfixed-size integers.\n\nNative-size modifiers are allowed on all of them, including `i`, `I`, `j`, and\n`J` for completeness.\n\nRepeat counts and globs are supported in the same way as fixed-size integers.\n\n### Floating-point values\n\nThese directives pack and unpack values of type `T`, where `T` <\n`Float::Primitive`. The type `T` depends on the directive being used:\n\n* `Float32`: `f` `e` `g`\n* `Float64`: `d` `E` `G`\n* `LibC::Float32`: `F`\n\nThe endianness also depends on the directive:\n\n* System endian: `d` `f` `F`\n* Little-endian: `e` `E`\n* Big-endian: `g` `G`\n\nThe `D` directive represents a native double-precision value in Ruby but a\nlong double value in Perl. To avoid confusion, this library does not support\n`D`, because Crystal doesn't support long doubles.\n\nEndianness and native-size modifiers are not allowed.\n\nRepeat counts and globs are supported in the same way as fixed-size integers.","summary":"<p>Crystal port of Perl / Ruby's <code><a href=\"Pack.html#pack(fmt,*args)-macro\">pack</a></code> / <code><a href=\"Pack.html#unpack(bytes,fmt)-macro\">unpack</a></code> functions.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[{"id":"pack(fmt,*args)-macro","html_id":"pack(fmt,*args)-macro","name":"pack","doc":"Packs *args* into a new writable `Bytes` according to the given format\nstring *fmt*.\n\nCommands that contain repeat counts or globs do not consume multiple\narguments.\n\n*fmt* must be a string literal or string constant representing a valid\nsequence of unpacking commands. The arity and types of *args* depend on the\ncommands given.\n\n```\nPack.pack(\"csl>\", 1_i8, 1000, 100000000) # => Bytes[0x01, 0xE8, 0x03, 0x05, 0xF5, 0xE1, 0x00]\n```","summary":"<p>Packs <em>args</em> into a new writable <code>Bytes</code> according to the given format string <em>fmt</em>.</p>","abstract":false,"args":[{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(fmt, *args)","location":{"filename":"src/pack/pack_impl.cr","line_number":500,"url":"https://github.com/HertzDevil/pack.cr/blob/09a8370973e7a1b763a2b2485d0de2362e84ffc6/src/pack/pack_impl.cr#L500"},"def":{"name":"pack","args":[{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":1,"block_arg":null,"visibility":"Public","body":"    \n%io\n = ::Pack::PackImpl::BytesWriter.new\n    ::Pack.pack_to(\n%io\n, \n{{ fmt }}\n, \n{{ args.splat }}\n)\n    \n%io\n.to_slice\n  \n"}},{"id":"pack_to(io,fmt,*args)-macro","html_id":"pack_to(io,fmt,*args)-macro","name":"pack_to","doc":"Packs *args* into the given *io* according to the given format string *fmt*.\nThe return value is unspecified.\n\nCommands that contain repeat counts or globs do not consume multiple\narguments.\n\n*io* must be an `IO`. *fmt* must be a string literal or string constant\nrepresenting a valid sequence of unpacking commands. The arity and types of\n*args* depend on the commands given.\n\n```\nio = IO::Memory.new\nPack.pack_to(io, \"csl>\", 1_i8, 1000, 100000000)\nio.to_slice # => Bytes[0x01, 0xE8, 0x03, 0x05, 0xF5, 0xE1, 0x00]\n```","summary":"<p>Packs <em>args</em> into the given <em>io</em> according to the given format string <em>fmt</em>.</p>","abstract":false,"args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""},{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(io, fmt, *args)","location":{"filename":"src/pack/pack_impl.cr","line_number":364,"url":"https://github.com/HertzDevil/pack.cr/blob/09a8370973e7a1b763a2b2485d0de2362e84ffc6/src/pack/pack_impl.cr#L364"},"def":{"name":"pack_to","args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""},{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":2,"block_arg":null,"visibility":"Public","body":"    \n{% if fmt.is_a?(Path) %}\n      {% fmt = fmt.resolve %}\n    {% end %}\n\n    \n{% if fmt.is_a?(StringLiteral) %}{% else %}\n      {% fmt.raise(\"format must be a string literal or constant\") %}\n    {% end %}\n\n\n    \n{% commands = [] of ASTNode %}\n\n    \n{% current = {directive: nil} %}\n\n\n    \n{% chars = fmt.chars %}\n\n    \n{% chars << ' ' %}\n\n    \n{% accepts_modifiers = false %}\n\n\n    \n{% for ch, index in chars %}\n      {% if \"cCsSlLqQiIjJnNvVdfFeEgGUwaAZbBhHumMpP@xX \\n\\t\\f\\v\\r\".includes?(ch) %}\n        {% if current[:directive] %}\n          {% current[:name] = chars[current[:index]...index].join(\"\") %}\n          {% commands << current %}\n        {% end %}\n\n        {% current = {directive: nil, index: index} %}\n        {% accepts_modifiers = false %}\n\n        {% if \" \\n\\t\\f\\v\\r\".includes?(ch) %}{% else %}\n          {% current[:directive] = ch %}\n          {% accepts_modifiers = \"sSlLqQjJiI\".includes?(ch) %}\n        {% end %}\n\n      {% else %}{% if (ch == '_') || (ch == '!') %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% current[:bang] = true %}\n\n      {% else %}{% if ch == '<' %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% if current[:endianness] == (:BigEndian)\n  fmt.raise(\"can't use both '<' and '>'\")\nend %}\n        {% current[:endianness] = :LittleEndian %}\n      {% else %}{% if ch == '>' %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% if current[:endianness] == (:LittleEndian)\n  fmt.raise(\"can't use both '<' and '>'\")\nend %}\n        {% current[:endianness] = :BigEndian %}\n\n      {% else %}{% if ch == '*' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:directive] == '@'\n  fmt.raise(\"#{ch} not allowed for '@'\")\nend %}\n        {% if current[:directive] == 'P'\n  fmt.raise(\"#{ch} not allowed for 'P'\")\nend %}\n        {% if current[:count]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:glob] = true %}\n\n      {% else %}{% if ch == '0' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 0 %}\n      {% else %}{% if ch == '1' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 1 %}\n      {% else %}{% if ch == '2' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 2 %}\n      {% else %}{% if ch == '3' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 3 %}\n      {% else %}{% if ch == '4' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 4 %}\n      {% else %}{% if ch == '5' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 5 %}\n      {% else %}{% if ch == '6' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 6 %}\n      {% else %}{% if ch == '7' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 7 %}\n      {% else %}{% if ch == '8' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 8 %}\n      {% else %}{% if ch == '9' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 9 %}\n\n      {% else %}{% if ch == 'D' %}\n        {% fmt.raise(\"long double is not supported, use 'd' instead\") %}\n\n      {% else %}\n        {% fmt.raise(\"unexpected directive: #{ch}\") %}\n      {% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}\n    {% end %}\n\n\n    \n%io\n = (\n{{ io }}\n).as(::IO)\n    \n%byte_offset\n = 0\n\n    \n{% arg_pos = 0 %}\n\n    \n{% for command in commands %}\n      {% if (command[:directive] == 'P') && command[:count] %}\n        {% fmt.raise(\"count not allowed for 'P'\") %}\n      {% end %}\n      {% if arg_pos >= args.size %}\n        {% args.raise(\"missing argument for directive #{name}\") %}\n      {% end %}\n      {% arg = args[arg_pos] %}\n      {% arg_pos += 1 %}\n      Pack::PackImpl.do_pack1(%io, %byte_offset, {{ arg }}, {{ command }})\n    {% end %}\n\n\n    \n{% if arg_pos < args.size %}\n      {% args.raise(\"wrong number of values for Pack.pack (expected #{arg_pos}, got #{args.size})\") %}\n    {% end %}\n\n  \n"}},{"id":"unpack(bytes,fmt)-macro","html_id":"unpack(bytes,fmt)-macro","name":"unpack","doc":"Unpacks a buffer of *bytes* according to the given format string *fmt*.\nReturns a `Tuple` of unpacked values, without flattening commands that\ncontain repeat counts or globs.\n\n*bytes* must be a `Bytes`. *fmt* must be a string literal or string constant\nrepresenting a valid sequence of unpacking commands.\n\n```\nPack.unpack(Bytes[0x01, 0xE8, 0x03, 0x05, 0xF5, 0xE1, 0x00], \"csl>\") # => {1_i8, 1000_i16, 100000000}\nPack.unpack(\"abcd\\x00ef\\x00\".to_slice, \"CCZ*a*\")                     # => {StaticArray[97_u8, 98_u8], Bytes[99, 100], Bytes[101, 102, 0]}\n```","summary":"<p>Unpacks a buffer of <em>bytes</em> according to the given format string <em>fmt</em>.</p>","abstract":false,"args":[{"name":"bytes","doc":null,"default_value":"","external_name":"bytes","restriction":""},{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""}],"args_string":"(bytes, fmt)","location":{"filename":"src/pack/unpack_impl.cr","line_number":402,"url":"https://github.com/HertzDevil/pack.cr/blob/09a8370973e7a1b763a2b2485d0de2362e84ffc6/src/pack/unpack_impl.cr#L402"},"def":{"name":"unpack","args":[{"name":"bytes","doc":null,"default_value":"","external_name":"bytes","restriction":""},{"name":"fmt","doc":null,"default_value":"","external_name":"fmt","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"    \n{% if fmt.is_a?(Path) %}\n      {% fmt = fmt.resolve %}\n    {% end %}\n\n    \n{% if fmt.is_a?(StringLiteral) %}{% else %}\n      {% fmt.raise(\"format must be a string literal or constant\") %}\n    {% end %}\n\n\n    \n{% commands = [] of ASTNode %}\n\n    \n{% current = {directive: nil} %}\n\n\n    \n{% chars = fmt.chars %}\n\n    \n{% chars << ' ' %}\n\n    \n{% accepts_modifiers = false %}\n\n\n    \n{% for ch, index in chars %}\n      {% if \"cCsSlLqQiIjJnNvVdfFeEgGUwaAZbBhHumMpP@xX \\n\\t\\f\\v\\r\".includes?(ch) %}\n        {% if current[:directive] %}\n          {% current[:name] = chars[current[:index]...index].join(\"\") %}\n          {% commands << current %}\n        {% end %}\n\n        {% current = {directive: nil, index: index} %}\n        {% accepts_modifiers = false %}\n\n        {% if \" \\n\\t\\f\\v\\r\".includes?(ch) %}{% else %}\n          {% current[:directive] = ch %}\n          {% accepts_modifiers = \"sSlLqQjJiI\".includes?(ch) %}\n        {% end %}\n\n      {% else %}{% if (ch == '_') || (ch == '!') %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% current[:bang] = true %}\n\n      {% else %}{% if ch == '<' %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% if current[:endianness] == (:BigEndian)\n  fmt.raise(\"can't use both '<' and '>'\")\nend %}\n        {% current[:endianness] = :LittleEndian %}\n      {% else %}{% if ch == '>' %}\n        {% unless accepts_modifiers\n  fmt.raise(\"#{ch} allowed only after directives sSiIlLqQjJ\")\nend %}\n        {% if current[:glob] || current[:count]\n  fmt.raise(\"#{ch} allowed only before '*' and count\")\nend %}\n        {% if current[:endianness] == (:LittleEndian)\n  fmt.raise(\"can't use both '<' and '>'\")\nend %}\n        {% current[:endianness] = :BigEndian %}\n\n      {% else %}{% if ch == '*' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:directive] == '@'\n  fmt.raise(\"#{ch} not allowed for '@'\")\nend %}\n        {% if current[:directive] == 'P'\n  fmt.raise(\"#{ch} not allowed for 'P'\")\nend %}\n        {% if current[:count]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:glob] = true %}\n\n      {% else %}{% if ch == '0' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 0 %}\n      {% else %}{% if ch == '1' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 1 %}\n      {% else %}{% if ch == '2' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 2 %}\n      {% else %}{% if ch == '3' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 3 %}\n      {% else %}{% if ch == '4' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 4 %}\n      {% else %}{% if ch == '5' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 5 %}\n      {% else %}{% if ch == '6' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 6 %}\n      {% else %}{% if ch == '7' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 7 %}\n      {% else %}{% if ch == '8' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 8 %}\n      {% else %}{% if ch == '9' %}\n        {% unless current[:directive]\n  fmt.raise(\"#{ch} allowed only after a directive\")\nend %}\n        {% if current[:glob]\n  fmt.raise(\"can't use both '*' and count\")\nend %}\n        {% current[:count] = ((current[:count] || 0) * 10) + 9 %}\n\n      {% else %}{% if ch == 'D' %}\n        {% fmt.raise(\"long double is not supported, use 'd' instead\") %}\n\n      {% else %}\n        {% fmt.raise(\"unexpected directive: #{ch}\") %}\n      {% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}{% end %}\n    {% end %}\n\n\n    \n%obj\n = Pack::UnpackImpl.to_slice(\n{{ bytes }}\n)\n    \n%byte_offset\n = 0\n\n    \n{% used_indices = [] of ASTNode %}\n\n    \n{% for command in commands %}\n      {% if \"@xX\".includes?(command[:directive]) %}\n        Pack::UnpackImpl.do_unpack1(%obj, %byte_offset, {{ command }})\n      {% else %}\n        %values{command[:index]} = Pack::UnpackImpl.do_unpack1(%obj, %byte_offset, {{ command }})\n        {% used_indices << command[:index] %}\n      {% end %}\n    {% end %}\n\n\n    Tuple.new(\n      \n{% for index in used_indices %}\n        %values{index},\n      {% end %}\n\n    )\n  \n"}}],"types":[]}]}}